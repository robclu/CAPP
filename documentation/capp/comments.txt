EVIEW 1 ---------------------
PAPER: 54
TITLE: CAPP : C++ Aspect-Oriented Parallel Programming with AspectC++ and OpenCL
AUTHORS: Robert Clucas and Stephen Levitt


----------- REVIEW -----------
This is a really interesting and well-written paper (and one of the best justifications that I have seen for
aspect-oriented programming - many of the examples presented to motivate for it seem trite).  There is a nice
logical organisation and flow to the paper.

I would have liked to see a little more detail on the Black-Scholes application (and some more discussion of
its very different performance characteristics), but I appreciate that there are length constraints on a
paper.  The authors should be careful of relying on colour to convey important information (I had printed out
the paper for review in monochrome, which made following some sections a little tricky).

A few minor typos, etc.:

1) some of the lines overlap into the right margin (e.g. plateau and CUDA on p. 1 - there are more cases
throughout the paper)

2) p. 2: "overheard" - should be "overhead"

3) p. 2: "...using aspects to modularize the complexities..." (not "modularizes")

4) p. 6, Listing 7: "parallel" (not "pallel")

5) p. 8, section 7: "...additional features which could be ideal candidates..." (not "are")

References:

[1] "CuPP" and "CUDA" (not "Cupp" and "cuda")

[5] The list of authors' names looks wrong (too many "ands", and "W.S.-P." looks wrong).  This paper should
also have page numbers.

[6] "CPU" and "GPU" - see [1]

[18] "SchrAuder" looks wrong

[20] "andAaimplementation"


----------------------- REVIEW 2 ---------------------
PAPER: 54
TITLE: CAPP : C++ Aspect-Oriented Parallel Programming with AspectC++ and OpenCL
AUTHORS: Robert Clucas and Stephen Levitt


----------- REVIEW -----------
This was a thoroughly interesting paper about the use of AOP specifically for parallel programming in a GPU
environment. The argument of using the author's CAPP system is well made, and the performance results look
interesting. The paper is very high-density, and to an extent the readability can be helped by better
typesetting.
* The use of colours in listings is likely to be tricky...is there no better/easier way to typeset this?
* Similarly, some of the class names (etc.) in the running text, should be typeset in other fonts (or at least
  other shapes) to make them stand out and perhaps better match what's being done in the listings.
* Figure 2 and 3 are tough to decipher at normal A4 paper scales (and in black and white) :-(.
* "doesn't" -> "does not"
* "temperature changes": I presume you mean temperature changes affecting clock speed on the CPU (and perhaps
  GPU, though I'm not aware they down-clock at higher temperatures). If this is suspected to be a real issue,
why not benchmark several times, or at a stabilised temperature?
* The references are a Latex typesetting disaster. Look very carefully at the resulting PDF, and not at the
  input Latex or Bibtex, to see the problems. In particular, cuda, cpu, gpu, etc., all come out lower-case
because they haven't been protected capitalised in the bibitem. There are a few cases of missing spaces, and
also a few cases of foreign accents which came out totally jumbled (there are a lot of online resources about
fixing that). There are also (perhaps in other parts of the paper) some uses of hyphens where "Emm" dashes
should've been used (look online as well). Finally, reference #7 is very suspicious to me. Is this really
someone's name (S.V. Group), or is this the Stanford Visualisation Group?


----------------------- REVIEW 3 ---------------------
PAPER: 54
TITLE: CAPP : C++ Aspect-Oriented Parallel Programming with AspectC++ and OpenCL
AUTHORS: Robert Clucas and Stephen Levitt


----------- REVIEW -----------
The paper reports on an aspect-oriented framework, CAPP, developed in order to be able to weave boiler-plate
code required for off-loading computations to an external multi-core processing device into application code
for which the parallel processing is required.

Even though parallel programming APIs like OpenCL and CUDA remove the need to interface at the hardware level
with parallel processing devices, these APIs still require relatively low-level code to exchange data between
the CPU machine and the parallel processing device (e.g.\ GPU) and device requiring a considerable amount of
code to be written in order to transfer data and request the parallel processing. A number of traditional
object-oriented and procedural frameworks have been developed to encapsulate the technical boiler-plate code
from  the application logic and to reduce the complexity developers have to face when off-loading computation
onto parallel processing devices. This paper reports on a novel approach of using aspects to encapsulate the
boiler-plate code and allow the specification of point-cuts which identify the target points where the aspects
are woven into (i.e.\ where the application code will be intercepted with logic encapsulated within aspects).

In order to assess the effectiveness of the framework, the authors implemented reference problems in (i)
vanilla C++ code using only the CPU resources on the machine, (ii) vanilla C++ code which does not use a
parallel computing device (ii) the low-level OpenCL framework and (iii) CAPP. As to be expected, comparing
cases CAPP to non parallel code resulted in a major performance benefit with a moderate to low increase in
code complexity and comparing CAPP to low-level OpenCL showed a low to moderate performance reduction but a
significant code reduction.

The paper is well written and the approach taken is clearly explained. There are, however, some serious
weaknesses in the paper. The first is that the performance and application complexity for the CAPP framework
is not compared to similar high-level frameworks, but only to non-parallelized code and code using the
low-level OpenCL framework. Instead CAPP should have been compared to the higher-level object-oriented and
procedural frameworks (e.g.\ CuPP, CAF, C++ AMP and RapidMind) as all of these have the same aims as CAPP,
i.e.\ to reduce the complexity and code bulk within application code.

The second major concern is that application code locks into the aspects woven into the application code.
Figure 1 gives the impression that the application code (top left box) is devoid of any logic specific to
off-loading computation to the parallel device (i.e.\ independent of the CAPP framework). This is indeed a
common benefit of and guideline for using aspects, i.e.\ the code to which aspects are applied should be
completely unaware of the aspects applied at point cuts and should be executable with or without the aspects
being applied. However, Listing 7, gives me the impression that the application code to which aspects are
applied is not fully decoupled from the CAPP framework -- it is hard-coded against the aspects by using the
RunKernel method defined in a base (abstract) aspect (see Listing 6). In many ways this nullifies any benefits
of using an aspect-oriented framework over that of using standard object-oriented or procedural frameworks.

For acceptance of this paper I recommend that the author should minimally
  (1) add a comparison of the performance and code bulk and complexity with at least one other high-level
framework
  (2) point out that the locking of the application code into CAPP is contrary to an aspect-oriented approach
and what the remaining benefits are of using an aspects over more traditional high-level frameworks.
